%% How to compile:
%% $ pdflatex report.tex
%% $ bibtex report.aux
%% $ pdflatex report.tex

%% Guidelines on the ACM Latex package:
%% https://authors.acm.org/proceedings/production-information/preparing-your-article-with-latex


%% format options: manuscript, acmsmall, acmlarge, acmtog, sigconf, siggraph, sigplan, sigchi
%% used formats: manuscript, sigplan
\documentclass[
  format=manuscript,
  screen=true,
  review=false,
  nonacm=true,
  timestamp=true,
  balance=false]{acmart}
\setcopyright{rightsretained}

\author{Alexander Christensen}
\title{C Scoped Enum Enhancements}
\email{alex\_c007@hotmail.com}

%% \citestyle{acmauthoryear}


%% ===================== %%
%% === CODE LISTINGS === %%
%% ===================== %%
\usepackage{listings}
\usepackage{color}

\definecolor{backgroundblue}{rgb}{0.93, 0.93, 1.0}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{LightCyan}{rgb}{0.88,1,1}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}
\definecolor{red}{rgb}{0.5,0.0,0.0}
\definecolor{blue}{rgb}{0.0,0.5,1.0}
\definecolor{green}{rgb}{0.0,0.5,0.0}


% basic settings, can be overrided
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  columns=fullflexible,
  escapeinside={\%},
  frame=none,
  backgroundcolor=\color{backgroundblue},
  showspaces=false,
  keepspaces=true,
  showstringspaces=false,
  showtabs=false,
  numbers=left,
  aboveskip=-3pt,
  sensitive=true
}


% nice horizontal line "-------- <text> --------", used above a listing
\def\headline#1{\begin{minipage}{36em}\vspace{4mm}\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill\end{minipage}}

% horizontal line, used below a listing
\newcommand{\lstline}{\vspace{-3mm}\hrulefill\vspace{2mm}\newline}


% fancy insert listing command
% example of usage: `\customlisting{FSharp}{Some Function}{<file.fsx>}`
\newcommand{\customlisting}[3]{\lstinputlisting[language=#1,name=#2]{#3}\lstline}


% Insert the code, e.g. from a file like this:
% \lstinputlisting[language=<language>]{<input_file>}
% \lstinputlisting[language=<language>, firstline=X, lastline=Y]{<input_file>}

% Or directly write the code in the .tex document:
% \begin{lstlisting}[language=<language>]

\lstdefinelanguage{Cpp}{
  morekeywords={float, int, double, uint, bool, if, for, else, void, class,
                struct, private, protected, public, enum, const, char, case,
                default, return, switch},
  keywordstyle=\color{bluekeywords},
  morecomment=[l][\color{greencomments}]{///},
  morecomment=[l][\color{greencomments}]{//},
  morecomment=[l][\color{redstrings}]{\#},
  morecomment=[s][\color{greencomments}]{{/*}{*/}},
  morestring=[b]",
  stringstyle=\color{redstrings},
  %title={\headline{\small C++ - \textit{\lstname}}}
}


%% =========================== %%
%% === ADDITIONAL PACKAGES === %%
%% =========================== %%
% Load with some options, i.e. \usepackage[colorlinks=true,linkcolor=blue]{hyperref} or blank
% \usepackage{hyperref}
%\usepackage[colorlinks=true,linkcolor=blue, linktocpage]{hyperref}


%% ================ %%
%% === DOCUMENT === %%
%% ================ %%
\begin{document}

%% \abstract{
%% This is a very abstract abstract.
%% }

\maketitle
\tableofcontents

\section{Introduction}

\section{Motivation and Scope}

The initial motivation for this proposal was the lack of a good way in the standard
library to convert an enum value to a proper string representation. Very often, I
have found a need to log an enum for various purposes, and every time I create a new
enum type I have to write such a function again. An example:

\begin{lstlisting}[language=Cpp]
enum class GraphicsApiType { none, opengl, vulkan };

const char* get_api_type_string(GraphicsApiType apiType) {
    switch (apiType) {
    case GraphicsApiType::none:   return "none";
    case GraphicsApiType::opengl: return "opengl";
    case GraphicsApiType::vulkan: return "vulkan";
    default: return "<unrecognized>";
    }
}
\end{lstlisting}

\noindent
This is cumbersome to maintain, for every time a value is added or modified inside
the enum type, this other function has to be modified as well. But besides this,
a potential \textit{run-time} error may be introduced when an invalid enum is
provided.

A session of browsing around sites such as StackOverflow revealed sometimes quite
vividly imaginary answers for how to circumvent this limitation in the language:

\begin{enumerate}
\item \url{https://stackoverflow.com/questions/11421432/how-can-i-output-the-value-of-an-enum-class-in-c11}
\item \url{https://stackoverflow.com/questions/1390703/enumerate-over-an-enum-in-c}
\item \url{https://stackoverflow.com/questions/6281461/enum-to-string-c}
\item \url{https://stackoverflow.com/questions/201593/is-there-a-simple-way-to-convert-c-enum-to-string}
\end{enumerate}

\noindent
Quite intuitively, two key observations were made:

\begin{itemize}
\item This proposal introduces \underline{changes to the core language}.
\item While fixing enum to string funcionality, there's a lot more that we could do at the same time.
\end{itemize}

\subsection{Scope for this proposal}

Only \textit{scoped enums} are extended with this proposal, because they are fully
type safe, meaning that we can theoretically perform all necessary computations needed
for this proposal \textit{compile-time}, with no risk of throwing exceptions or using
any other runtime mechanism.


\section{Impact on the Standard}

This proposal requires new language features, because certain enum extensions cannot
be covered by simply writing a library. The impacts are listed below with a subsection
for each of them.


\section{Proposed Notation}

Given my limited experience (actually: none) in writing C++ proposals, I know what I
\underline{would like} the proposal to address and introduce to the core language,
but not necessarily \underline{how it should be done}.

\section{Convert scoped enum to string}

Two ways of obtaining a string is suggested - the simple one, and a fully-qualified
one which contains namespaces, classes, and other scopes:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
namespace graphics {
    enum class GraphicsApiType { none, opengl, vulkan };
}
std::cout << std::enum_str<GraphicsApiType::opengl>() << std::endl;
// --> "opengl"
std::cout << std::enum_str_full<GraphicsApiType::opengl>() << std::endl;
// "graphics::GraphicsApiType::opengl"
\end{lstlisting}

\noindent
The return type itself gives us a number of possibilites, but two are probably worthy
of consideration: \texttt{const char*} and \texttt{std::string\_view}.

\section{Concept for "is-an-enum"}

We can with C++-23 create a concept which is useful for template substitution:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<typename T>
concept scoped_enum = std::is_scoped_enum_v<T>;

template<std::scoped_enum T>
class foo { int bar; };

// Try it out:
foo<GraphicsApiType> f1; // <-- success!
foo<unsigned long> f2; // <-- fails to compile!
\end{lstlisting}

\section{Iterating through a scoped enum}

Another interesting scenario is if an enum contains "identifiers", where for each we
want to create some data structure and add that to some general storage. An example
of such storage is shown below, using the \texttt{scoped\_enum} concept proposed
earlier:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum E, typename T>
class EnumMap {
public:
    bool has_value(E e) { return mEnumMap.contains(e); }
    void add_value(E e, T&& t) { mEnumMap[e] = t; }
    std::optional<T> get_value(E e) {
        if (auto it = mEnumMap.find(e); it != mEnumMap.end()) {
            return { it->second };
        } else { return std::nullopt; }
    }
private:
    std::map<E, T> mEnumMap;
};
\end{lstlisting}

We can then obtain a "bi-directional" iterator, which allows us to iterate through
all values in the enumeration and add them to the storage:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
void fill(EnumMap<auto T, auto V>& em) {
    for (T t : std::enum_values<T>)
        em.add value(t, V{});
}
\end{lstlisting}









\section{Design Decisions}



\section{Technical Specifications}

\section{Acknowledgements}

\section{References}




%% \bibliographystyle{ACM-Reference-Format}
%% \bibliography{references}

\end{document}

