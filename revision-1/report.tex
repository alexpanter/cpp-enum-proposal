%% How to compile:
%% $ pdflatex report.tex
%% $ bibtex report.aux
%% $ pdflatex report.tex

%% Guidelines on the ACM Latex package:
%% https://authors.acm.org/proceedings/production-information/preparing-your-article-with-latex


%% format options: manuscript, acmsmall, acmlarge, acmtog, sigconf, siggraph, sigplan, sigchi
%% used formats: manuscript, sigplan
\documentclass[
  format=manuscript,
  screen=true,
  review=false,
  nonacm=true,
  timestamp=true,
  balance=false]{acmart}
\setcopyright{rightsretained}

\author{Alexander Christensen}
\title{C++ Scoped Enum Enhancements}
\email{<alex\_c007@hotmail.com>}

%% \citestyle{acmauthoryear}


%% ===================== %%
%% === CODE LISTINGS === %%
%% ===================== %%
\usepackage{listings}
\usepackage{color}

\definecolor{backgroundblue}{rgb}{0.93, 0.93, 1.0}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{LightCyan}{rgb}{0.88,1,1}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}
\definecolor{red}{rgb}{0.5,0.0,0.0}
\definecolor{blue}{rgb}{0.0,0.5,1.0}
\definecolor{green}{rgb}{0.0,0.5,0.0}


% basic settings, can be overrided
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  columns=fullflexible,
  escapeinside={\%},
  frame=none,
  backgroundcolor=\color{backgroundblue},
  showspaces=false,
  keepspaces=true,
  showstringspaces=false,
  showtabs=false,
  numbers=left,
  aboveskip=-3pt,
  sensitive=true
}


% nice horizontal line "-------- <text> --------", used above a listing
\def\headline#1{\begin{minipage}{36em}\vspace{4mm}\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill\end{minipage}}

% horizontal line, used below a listing
\newcommand{\lstline}{\vspace{-3mm}\hrulefill\vspace{2mm}\newline}


% fancy insert listing command
% example of usage: `\customlisting{FSharp}{Some Function}{<file.fsx>}`
\newcommand{\customlisting}[3]{\lstinputlisting[language=#1,name=#2]{#3}\lstline}


% Insert the code, e.g. from a file like this:
% \lstinputlisting[language=<language>]{<input_file>}
% \lstinputlisting[language=<language>, firstline=X, lastline=Y]{<input_file>}

% Or directly write the code in the .tex document:
% \begin{lstlisting}[language=<language>]

\lstdefinelanguage{Cpp}{
  morekeywords={float, int, double, uint, bool, if, for, else, void, class,
                struct, private, protected, public, enum, const, char, case,
                default, return, switch, template, constexpr, noexcept, auto,
                typename, namespace, concept, static, unsigned, consteval,
                long},
  keywordstyle=\color{bluekeywords},
  morecomment=[l][\color{greencomments}]{///},
  morecomment=[l][\color{greencomments}]{//},
  morecomment=[l][\color{redstrings}]{\#},
  morecomment=[s][\color{greencomments}]{{/*}{*/}},
  morestring=[b]",
  stringstyle=\color{redstrings},
  %title={\headline{\small C++ - \textit{\lstname}}}
}


%% =========================== %%
%% === ADDITIONAL PACKAGES === %%
%% =========================== %%
% Load with some options, i.e. \usepackage[colorlinks=true,linkcolor=blue]{hyperref} or blank
% \usepackage{hyperref}
%\usepackage[colorlinks=true,linkcolor=blue, linktocpage]{hyperref}
\usepackage{stackengine}
\newlength\llength
\llength=\linewidth\relax


%% ================ %%
%% === DOCUMENT === %%
%% ================ %%
\begin{document}

%% \abstract{
%% This is a very abstract abstract.
%% }

\maketitle
\tableofcontents

\section{Introduction}

This proposal is the first revision of "C++ Scoped Enum Proposal", which was circulated
in the C++ proposals email list during the winter of 2021/2022. The goal of writing
this proposal is to gain feedback and insights, which may then be used for further
revisions.

\noindent
Note: This proposal targets only \underline{scoped enums}, and does not provide any
effort to address \textit{unscoped} enums.

\vspace{2mm}\noindent
Given my limited experience (actually: none) in writing C++ proposals, I know what I
\underline{would like} the proposal to address and introduce to the core language,
but not necessarily \underline{how it should be done}. The suggested notations
provided are, thus, merely suggestions - and not concrete proposals for a concious
choice of syntax.


\section{Motivation and Scope}

The initial motivation for this proposal was the lack of a good way in the standard
library to convert an enum value to a proper string representation. Very often, I
have found a need to log an enum for various purposes, and every time I create a new
enum type I have to write such a function again. An example:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
enum class GraphicsApiType { none, opengl, vulkan };

const char* get_api_type_string(GraphicsApiType apiType) {
    switch (apiType) {
    case GraphicsApiType::none:   return "none";
    case GraphicsApiType::opengl: return "opengl";
    case GraphicsApiType::vulkan: return "vulkan";
    default: return "<unrecognized>";
    }
}
\end{lstlisting}

\noindent
This is cumbersome to maintain, for every time a value is added or modified inside
the enum type, this other function has to be modified as well. But besides this,
a potential \textit{run-time} error may be introduced when an invalid enum is
provided.

A session of browsing around sites such as StackOverflow revealed sometimes quite
vividly imaginary answers for how to circumvent this limitation in the language:

\begin{enumerate}
\item \url{https://stackoverflow.com/questions/11421432/how-can-i-output-the-value-of-an-enum-class-in-c11}
\item \url{https://stackoverflow.com/questions/1390703/enumerate-over-an-enum-in-c}
\item \url{https://stackoverflow.com/questions/6281461/enum-to-string-c}
\item \url{https://stackoverflow.com/questions/201593/is-there-a-simple-way-to-convert-c-enum-to-string}
\end{enumerate}

\noindent
Quite intuitively, two key observations were made:

\begin{itemize}
\item This proposal introduces \underline{changes to the core language}.
\item While fixing enum to string functionality, there's a lot more that we could do at the same time.
\end{itemize}

\subsection{Scope for this proposal}

Only \textit{scoped enums} are extended with this proposal, because they are fully
type safe, meaning that we can theoretically perform all necessary computations needed
for this proposal \textit{compile-time}, with no risk of throwing exceptions or using
any other runtime mechanism.


\section{Impact on the Standard}

This proposal requires new language features, because certain enum extensions cannot
be covered by simply writing a library. The impacts are listed below with a subsection
for each of them.



\section{Proposed features}

\subsection{Convert scoped enum to string}

Two ways of obtaining a string is suggested - the simple one, and a fully-qualified
one which contains namespaces, classes, and other scopes:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
namespace graphics {
    enum class GraphicsApiType { none, opengl, vulkan };
}

template<std::scoped_enum T> // <-- concept defined in next subsection
constexpr std::string_view enum_str(T t) { /* implemented in the compiler */ }

std::cout << std::enum_str<GraphicsApiType::opengl>() << std::endl;
// --> "opengl"
std::cout << std::enum_str_full<GraphicsApiType::opengl>() << std::endl;
// "graphics::GraphicsApiType::opengl"
\end{lstlisting}

\noindent
The return type itself gives us a number of possibilites, but two are probably worthy
of consideration: \texttt{const char*} and \texttt{std::string\_view}. It is probably
also worth considering what notation is \textit{optimal}. In the example above, we
have a templated function which return a \texttt{constexpr} string representation.

\vspace{2mm}\noindent
Note: I am unsure how best to write this.


\subsection{Concept for "is-an-enum"}

We can with C++-23 create a concept which is useful for template substitution:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<typename T>
concept scoped_enum = std::is_scoped_enum_v<T>;

template<std::scoped_enum T>
class foo { int bar; };

// Try it out:
foo<GraphicsApiType> f1; // <-- success!
foo<unsigned long> f2; // <-- fails to compile!
\end{lstlisting}


\subsection{Obtain the underlying type}

In current C++, when needing to compare an enum value to its underlying type,
a relatively verbose expression is needed which involves a "\texttt{static\_cast}"
and possible also an "\texttt{std::underlying\_type}". This has been somewhat
mitigated by the introduction of \texttt{std::to\_underlying}, available with C++23,
but this proposal adds a new template meta-function which does almost the same
thing:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<scoped_enum E>
struct enum_type {
    using type = std::underlying_type<E>::type;
};

template<scoped_enum E>
using enum_type_t = std::enum_type<E>::type;

// Try it out:
enum class Color : int { red, green, blue, yellow };
std::enum_type_t<Color> yellow = Color::yellow;
\end{lstlisting}

The benefit of this meta-function, as opposed to \texttt{std::to\_underlying}, is
that this meta-function does not work for unscoped enumerations. This is because
\texttt{std::to\_underlying} uses \texttt{std::underlying\_type}, while this new
meta-function uses the newly proposed concept \texttt{std::scoped\_enum}.
This creates a more accentuated difference between scoped and unscoped enums, and
thereby encourages the use of scoped enums for enhanced type safety and scope
safety.


\subsection{Get the underlying value}

Similar to how getting an underlying type can be tedious, this proposal also
addresses the need for obtaining the underlying value of a scoped enum value:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<scoped_enum Enum>
constexpr std::enum_type_t<Enum> enum_value(Enum e) noexcept
{
    // TODO: Error - use enum_cast instead!
    return static_cast<std::enum_type_t<Enum>>(e);
}
\end{lstlisting}


\subsection{Safe enum conversion (language feature)}

Sometimes, a conversion from an underlying type to an enum value may be approved
without being valid. And there exists no compile-time feature to check for this.
An example of how it may go wrong:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
enum class MyScopedEnum : int
{
    value_0 = 0, value_1 = 1, value_2 = 2, value_3 = 3, value_43 = 43, value_57 = 57
};

constexpr MyScopedEnum test = static_cast<MyScopedEnum>(56);
\end{lstlisting}

\noindent
Even if we explicitly denote our variable \texttt{constexpr}, the compiler is not
able to enforce correct behaviour, and so we obtain undefined behaviour. The topic
is discussed on StackOverflow:

\noindent
\url{https://stackoverflow.com/questions/17811179/safe-way-to-convert-an-integer-in-an-enum}

\vspace{3mm}\noindent
This proposal thus defines a template meta-function which fails at
\underline{compile-time} if the conversion is invalid. It might be possible to also
define a \textit{run-time} mechanism which throws an exception, but this revision
does not discuss that topic further (for now). Proposed syntax:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum T>
constexpr bool is_enum_convertible(std::enum_type_t<T> t) {
    return ...; // <-- compiler implements this
};

template<std::scoped_enum T>
consteval T enum_cast(std::enum_type_t<T> t) {
    static_assert(std::is_enum_convertible<T>(t));
    return static_cast<T>(t);
}
\end{lstlisting}


\subsection{IMPROVED Safe enum conversion (language feature)}



%% NOTE: Borrowed from:
%% https://tex.stackexchange.com/questions/168741/showing-two-listings-in-a-table-side-by-side
\setbox0=\hbox{%
\begin{minipage}{0.45\linewidth}
\begin{center}
Current C++, \texttt{static\_cast} is unsafe.\vspace{2mm}
\end{center}
\begin{lstlisting}[language=Cpp, basicstyle={\footnotesize\ttfamily}]
enum class MyScopedEnum : int
{
    val_0 = 0, val_1 = 1, val_2 = 2
};

// FAIL: Compiler thinks this is okay
MyScopedEnum e = static_cast<MyScopedEnum>(4);
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
\begin{minipage}{0.45\linewidth}
\begin{center}
Proposed restriction to \texttt{static\_cast}.\vspace{2mm}
\end{center}
\begin{lstlisting}[language=Cpp, basicstyle={\footnotesize\ttfamily}]
enum class MyScopedEnum : int
{
    val_0 = 0, val_1 = 1, val_2 = 2
};

// GOOD: Compiler throws an error
MyScopedEnum e = static_cast<MyScopedEnum>(4);
\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\begin{center}
\begin{tabular}{ccc}
\listingA & \hspace{5mm} & \listingB \\
\end{tabular}
\end{center}




\subsection{Iterating through a scoped enum}

Another interesting scenario is if an enum contains "identifiers", where for each we
want to create some data structure and add that to some general storage. An example
of such storage is shown below, using the \texttt{scoped\_enum} concept proposed
earlier:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum E, typename T>
class EnumMap {
public:
    bool has_value(E e) { return mEnumMap.contains(e); }
    void add_value(E e, T&& t) { mEnumMap[e] = t; }
    std::optional<T> get_value(E e) {
        if (auto it = mEnumMap.find(e); it != mEnumMap.end()) {
            return { it->second };
        } else { return std::nullopt; }
    }
private:
    std::map<E, T> mEnumMap;
};
\end{lstlisting}

We can then obtain a "bi-directional" iterator, which allows us to iterate through
all values in the enumeration and add them to the storage:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
void fill(EnumMap<auto T, auto V>& em) {
    for (T t : std::enum_values<T>)
        em.add value(t, V{});
}
\end{lstlisting}


\subsection{Enum Cardinality}

Another feature which might sometimes be useful, is the ability to count the number
of values inside an enumeration. A real-world example, here found in the
\texttt{glslang} library for shader compilation:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
typedef enum {
    EShSourceNone,
    EShSourceGlsl,               // GLSL, includes ESSL (OpenGL ES GLSL)
    EShSourceHlsl,               // HLSL
    LAST_ELEMENT_MARKER(EShSourceCount),
} EShSource;                     // if EShLanguage were EShStage, this could be EShLanguage instead
\end{lstlisting}

Granted, this is a \texttt{C} library, but the use case for \texttt{C++} would be
identical. And it would likely be used for validating the input because \texttt{enums}
are unsafe:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
void my_function(EShSource e) {
    if (e < 0 || e >= LAST_ELEMENT_MARKER) {
        // report an error...
    }
}
\end{lstlisting}


\noindent
This proposal then adds a new template meta-function, which at compile time computes
the number of elements - ie. the \textit{cardinality} - of a scoped enumueration:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<scoped_enum E>
struct enum_cardinality {
    static constexpr std::size_t value = 1; // <-- compiler implements this
};

template<scoped_enum E>
std::size_t enum_cardinality_v = std::enum_cardinality<E>::value;

// Try it out:
enum class Weekday { monday, tuesday, /* etc. */ };
static_assert(std::enum_cardinality_v<Weekday> == 7);
\end{lstlisting}

\noindent
The example from before could be written, then, in a manner both type safe and
value safe, with no scope leakage:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
enum class EShSource : int {
    EShSourceNone = 0, EShSourceGlsl, EShSourceHlsl
};

void my_function(EShSource e) {
    if (std::enum_value(e) < 0 || std::enum_value(e) >= std::enum_cardinality_v<EShSource>) {
        // report an error...
    }
}
\end{lstlisting}

And this leads us to the next topic..


\subsection{Enum bounds checking}

It's annoying to write the statement in \texttt{my\_function} above, so there
should also be a shorthand notation for that, thusly proposed:

\begin{lstlisting}[language=Cpp]

enum class EShSource : int {
    EShSourceNone = 0, EShSourceGlsl, EShSourceHlsl
};

void my_function(EShSource e) {
    if (std::enum_value(e) < 0 || std::enum_value(e) >= std::enum_cardinality_v<EShSource>) {
        // report an error...
    }
}
\end{lstlisting}

\noindent
\textbf{NOTE: We absolutely MUST test that enums are not given custom values, ie.
only default in range [0, cardinality-1], OTHERWISE bounds checking cannot work properly!}



\subsection{Enum position}

We might also want to know the position or the \textit{index} of an enum value
inside an enumeration. As with \texttt{std::enum\_cardinality}, we need to rely
on the compiler to provide an implementation, as well as a requirement of strict
compile-time evaluation:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum T, T E>
struct enum_position {
    static constexpr std::size_t value = 0; // <-- compiler implements this
};

template<std::scoped_enum T, T E>
std::size_t enum_position_v = std::enum_position<T, E>::value;

// Try it out:
enum class Fruit { banana = 1, apple = 2, orange = 4, clementine = 8 };
static assert(std::enum_value_v<Fruit::orange> == 4);
static assert(std::enum_position<Fruit, Fruit::orange> == 2);
\end{lstlisting}

\noindent
With both \texttt{enum\_cardinality} and \texttt{enum\_position} implemented, we
can create e.g. create a priority mapper with a priority for each enum value:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum T>
class EnumPriorityMapper {
public:
    unsigned int GetPriority(T t) {
        return mPriorities[std::enum_position_v<T, t>];
    }
    void SetPriority(T t, unsigned int p) {
        mPriorities[std::enum_position_v<T, t>] = p;
    }
private:
    unsigned int mPriorities[std::enum_cardinality_v<T>];
};
\end{lstlisting}


\subsection{Weak ordering}

With a good comparison operator in place, it becomes straight-forward to test
the order in which values appear inside an enumeration. Using the "spaceship operator"
introduced with C++20, this proposal defines two three-way comparison functions:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum T>
constexpr std::weak_ordering operator<=>(T t, std::integral auto i) {
    return std::enum_value(t) <=> i;
}

template<std::scoped_enum T>
std::weak_ordering operator<=>(T s, T t) {
    return std::enum_value(s) <=> std::enum_value(t);
}

// Try it out:
enum class MyScopedEnum : int {
    value_0 = 0, value_1 = 1, value_2 = 2, value_3 = 3, value_43 = 43, value_57 = 57
};
static_assert((MyScopedEnum::value_0 <=> 0) == 0);
static_assert((1 <=> MyScopedEnum::value_2) < 0);
static_assert((MyScopedEnum::value_2 <=> 1) > 0);
\end{lstlisting}


\subsection{Enum as bit flag}

It may be desireable to have the option to specify a scoped enum type as a bit flag,
so that its values may be used to create bitmasks. In other words, we want a syntax
which allows a use case like this:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
enum class MemoryUsageFlag {
    device_local, host_visible, host_coherent, host_cached, lazily_allocated, is_protected
};

auto memFlags = MemoryUsageFlag::device_local
              | MemoryUsageFlag::lazily_allocated; // <-- Error: No operator defined.
\end{lstlisting}

\noindent
But this is not currently possible without the use of \texttt{static\_cast}. And so
this proposal defines some overloaded bitwise operators, so that scoped enums may be
used as bit flags in a way that is \underline{type safe} and fully supported by the
language:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
template<std::scoped_enum T>
constexpr std::enum_type_t<T> operator| (T s, T t)
{
    return std::enum_type_t<T>(s) | std::enum_type_t<T>(t);
}

template<std::scoped_enum T>
constexpr bool operator& (std::enum_type_t<T> f, T t)
{
    return f & std::enum_value(t);
}

template<std::scoped_enum T>
constexpr bool operator& (T t, std::enum_type_t<T> f)
{
    return std::enum_value(t) & f;
}
\end{lstlisting}

\noindent
These operators allow for \underline{compile-time} checks through \texttt{static\_cast},
and lets us use scoped enums as fully type-safe bitmasking operands. Exemplified:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
enum class EnumFlags : uint32_t {
    flag_1 = 0x01,
    flag_2 = 0x02,
    flag_4 = 0x04,
    flag_8 = 0x08
};

constexpr auto flags = EnumFlags::flag_1 | EnumFlags::flag_2;
static_assert(flags & EnumFlags::flag_1);
static_assert(!(EnumFlags::flag_8 & flags));
\end{lstlisting}



\section{Proposed Notation Summary}

In summary, there's a lot of new features that would \textit{significantly} improve
the usage of scoped enums. Some of these may be implemented as library features,
while others simply cannot be written with current C++. Since most of the symbols
defined are dependent upon \texttt{std::is\_scoped\_enum}, C++23 is the
\textit{minimal} requirement for an implementation of this proposal. A quick overview
of the function and meta-function signatures are listed here:\vspace{2mm}

\begin{lstlisting}[language=Cpp]
#include <type_traits>

namespace std {
    template<typename T>
    concept scoped_enum = std::is_scoped_enum_v<T>;

    template<scoped_enum E>
    struct enum_cardinality {
        static constexpr std::size_t value; // Implementation-defined
    };

    template<scoped_enum E>
    std::size_t enum_cardinality_v = std::enum_cardinality<E>::value;

    template<std::scoped_enum T, T E>
    struct enum_position {
        static constexpr std::size_t value = 0; // Implementation-defined
    };

    template<std::scoped_enum T, T E>
    std::size_t enum_position_v = std::enum_position<T, E>::value;

    template<scoped_enum E>
    struct enum_type {
        using type = std::underlying_type<E>::type;
    };

    template<scoped_enum E>
    using enum_type_t = std::enum_type<E>::type;

    template<scoped_enum Enum>
    constexpr std::enum_type_t<Enum> enum_value(Enum e) noexcept {
        return static_cast<std::enum_type_t<Enum>>(e);
    }
} // namespace std

template<std::scoped_enum T>
constexpr std::weak_ordering operator<=>(T t, std::integral auto i)
{
    return std::enum_value(t) <=> i;
}

template<std::scoped_enum T>
std::weak_ordering operator<=>(T s, T t)
{
    return std::enum_value(s) <=> std::enum_value(t);
}

template<std::scoped_enum T>
constexpr std::enum_type_t<T> operator| (T s, T t)
{
    return std::enum_type_t<T>(s) | std::enum_type_t<T>(t);
}

template<std::scoped_enum T>
constexpr bool operator& (std::enum_type_t<T> f, T t)
{
    return f & std::enum_value(t);
}

template<std::scoped_enum T>
constexpr bool operator& (T t, std::enum_type_t<T> f)
{
    return std::enum_value(t) & f;
}
\end{lstlisting}



\section{Design Decisions}

The overall design goals have been twofold:

\begin{enumerate}
\item Provide enhancements that all operate \underline{compile-time}.
\item Only provide enhancements for the type-safe scoped enums. Do nothing for the "old" C-style enums.
\end{enumerate}

\noindent
As such, most features have been written with the proposed syntax of template
meta-functions, with the use of modern C++ features such as \texttt{concepts} and
"three-way comparison" (\texttt{<=>}). The proposed syntax are merely
\textit{suggestions}, ie. "what I want", and not necessarily "how I want it".


\section{Technical Specifications}

\section{Acknowledgements}

\section{References}




%% \bibliographystyle{ACM-Reference-Format}
%% \bibliography{references}

\end{document}

